"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.prepare = exports.prepareDynamicExtensions = void 0;
const planner = require("./planner");
const deploymentSummary = require("./deploymentSummary");
const prompt = require("../../prompt");
const refs = require("../../extensions/refs");
const projectUtils_1 = require("../../projectUtils");
const logger_1 = require("../../logger");
const error_1 = require("../../error");
const requirePermissions_1 = require("../../requirePermissions");
const extensionsHelper_1 = require("../../extensions/extensionsHelper");
const secretsUtils_1 = require("../../extensions/secretsUtils");
const secrets_1 = require("./secrets");
const warnings_1 = require("../../extensions/warnings");
const etags_1 = require("../../extensions/etags");
const v2FunctionHelper_1 = require("./v2FunctionHelper");
const tos_1 = require("../../extensions/tos");
const common_1 = require("../../extensions/runtimes/common");
const projectConfig_1 = require("../../functions/projectConfig");
const functionsDeployHelper_1 = require("../functions/functionsDeployHelper");
async function prepareHelper(context, options, payload, wantExtensions, noDeleteExtensions, isPrimaryCall) {
    var _a, _b;
    const projectId = (0, projectUtils_1.needProjectId)(options);
    context.have = await planner.have(projectId);
    context.want = wantExtensions;
    const etagsChanged = (0, etags_1.detectEtagChanges)(options.rc, projectId, context.have);
    if (etagsChanged.length) {
        const wantChangedIds = wantExtensions
            .map((e) => e.instanceId)
            .filter((id) => etagsChanged.includes(id));
        if (wantChangedIds.length) {
            (0, warnings_1.outOfBandChangesWarning)(wantChangedIds);
            if (!(await prompt.confirm({
                message: `Do you wish to continue deploying these extension instances?`,
                default: false,
                nonInteractive: options.nonInteractive,
                force: options.force,
            }))) {
                throw new error_1.FirebaseError("Deployment cancelled");
            }
        }
    }
    const usingSecrets = await Promise.all((_a = context.want) === null || _a === void 0 ? void 0 : _a.map(secrets_1.checkSpecForSecrets));
    if (usingSecrets.some((i) => i)) {
        await (0, secretsUtils_1.ensureSecretManagerApiEnabled)(options);
    }
    const usingV2Functions = await Promise.all((_b = context.want) === null || _b === void 0 ? void 0 : _b.map(v2FunctionHelper_1.checkSpecForV2Functions));
    if (usingV2Functions) {
        await (0, v2FunctionHelper_1.ensureNecessaryV2ApisAndRoles)(options);
    }
    payload.instancesToCreate = context.want.filter((i) => { var _a; return !((_a = context.have) === null || _a === void 0 ? void 0 : _a.some(matchesInstanceId(i))); });
    payload.instancesToConfigure = context.want.filter((i) => { var _a; return (_a = context.have) === null || _a === void 0 ? void 0 : _a.some(isConfigure(i)); });
    payload.instancesToUpdate = context.want.filter((i) => { var _a; return (_a = context.have) === null || _a === void 0 ? void 0 : _a.some(isUpdate(i)); });
    payload.instancesToDelete = context.have.filter((i) => { var _a; return !((_a = context.want) === null || _a === void 0 ? void 0 : _a.some(matchesInstanceId(i))) && !(noDeleteExtensions === null || noDeleteExtensions === void 0 ? void 0 : noDeleteExtensions.some(matchesInstanceId(i))); });
    if (await (0, warnings_1.displayWarningsForDeploy)(payload.instancesToCreate)) {
        if (!(await prompt.confirm({
            message: `Do you wish to continue deploying these extension instances?`,
            default: true,
            nonInteractive: options.nonInteractive,
            force: options.force,
        }))) {
            throw new error_1.FirebaseError("Deployment cancelled");
        }
    }
    const permissionsNeeded = [];
    if (!isPrimaryCall) {
        payload.instancesToDelete = [];
    }
    if (payload.instancesToCreate.length) {
        permissionsNeeded.push("firebaseextensions.instances.create");
        logger_1.logger.info(deploymentSummary.createsSummary(payload.instancesToCreate));
    }
    if (payload.instancesToUpdate.length) {
        permissionsNeeded.push("firebaseextensions.instances.update");
        logger_1.logger.info(deploymentSummary.updatesSummary(payload.instancesToUpdate, context.have));
    }
    if (payload.instancesToConfigure.length) {
        permissionsNeeded.push("firebaseextensions.instances.update");
        logger_1.logger.info(deploymentSummary.configuresSummary(payload.instancesToConfigure));
    }
    if (payload.instancesToDelete.length) {
        logger_1.logger.info(deploymentSummary.deletesSummary(payload.instancesToDelete));
        if (!(await prompt.confirm({
            message: `Would you like to delete ${payload.instancesToDelete
                .map((i) => i.instanceId)
                .join(", ")}?`,
            default: false,
            nonInteractive: options.nonInteractive,
            force: options.force,
        }))) {
            payload.instancesToDelete = [];
        }
        else {
            permissionsNeeded.push("firebaseextensions.instances.delete");
        }
    }
    await (0, requirePermissions_1.requirePermissions)(options, permissionsNeeded);
    await (0, tos_1.acceptLatestAppDeveloperTOS)(options, projectId, context.want.map((i) => i.instanceId));
}
async function prepareDynamicExtensions(context, options, payload, builds) {
    const filters = (0, functionsDeployHelper_1.getEndpointFilters)(options);
    const extensions = (0, common_1.extractExtensionsFromBuilds)(builds, filters);
    const isApiEnabled = await (0, extensionsHelper_1.checkExtensionsApiEnabled)(options);
    if (Object.keys(extensions).length === 0 && !isApiEnabled) {
        return;
    }
    const projectId = (0, projectUtils_1.needProjectId)(options);
    const projectNumber = await (0, projectUtils_1.needProjectNumber)(options);
    const aliases = (0, projectUtils_1.getAliases)(options, projectId);
    const projectDir = options.config.projectDir;
    const isPrimaryCall = !!options.only && !options.only.split(",").includes("extensions");
    await (0, extensionsHelper_1.ensureExtensionsApiEnabled)(options);
    await (0, requirePermissions_1.requirePermissions)(options, ["firebaseextensions.instances.list"]);
    const dynamicWant = await planner.wantDynamic({
        projectId,
        projectNumber,
        extensions,
    });
    let noDeleteExtensions = [];
    if (isPrimaryCall) {
        const firebaseJsonWant = await planner.want({
            projectId,
            projectNumber,
            aliases,
            projectDir,
            extensions: options.config.get("extensions", {}),
        });
        noDeleteExtensions = noDeleteExtensions.concat(firebaseJsonWant);
        if (hasNonDeployingCodebases(options)) {
            const dynamicAll = await planner.wantDynamic({
                projectId,
                projectNumber,
                extensions: await (0, common_1.extractAllDynamicExtensions)(options),
            });
            noDeleteExtensions = noDeleteExtensions.concat(dynamicAll);
        }
    }
    return prepareHelper(context, options, payload, dynamicWant, noDeleteExtensions, isPrimaryCall);
}
exports.prepareDynamicExtensions = prepareDynamicExtensions;
function hasNonDeployingCodebases(options) {
    const functionFilters = (0, functionsDeployHelper_1.getEndpointFilters)(options);
    if (functionFilters === null || functionFilters === void 0 ? void 0 : functionFilters.length) {
        return true;
    }
    const functionsConfig = (0, projectConfig_1.normalizeAndValidate)(options.config.src.functions);
    const allCodebases = (0, functionsDeployHelper_1.targetCodebases)(functionsConfig);
    const deployingCodebases = (0, functionsDeployHelper_1.targetCodebases)(functionsConfig, functionFilters);
    if (allCodebases.length > deployingCodebases.length) {
        return true;
    }
}
async function prepare(context, options, payload) {
    context.extensionsStartTime = Date.now();
    const projectId = (0, projectUtils_1.needProjectId)(options);
    const projectNumber = await (0, projectUtils_1.needProjectNumber)(options);
    const aliases = (0, projectUtils_1.getAliases)(options, projectId);
    const projectDir = options.config.projectDir;
    await (0, extensionsHelper_1.ensureExtensionsApiEnabled)(options);
    await (0, requirePermissions_1.requirePermissions)(options, ["firebaseextensions.instances.list"]);
    const firebaseJsonWant = await planner.want({
        projectId,
        projectNumber,
        aliases,
        projectDir,
        extensions: options.config.get("extensions", {}),
    });
    const dynamicWant = await planner.wantDynamic({
        projectId,
        projectNumber,
        extensions: await (0, common_1.extractAllDynamicExtensions)(options),
    });
    return prepareHelper(context, options, payload, firebaseJsonWant, dynamicWant, true);
}
exports.prepare = prepare;
const matchesInstanceId = (dep) => (test) => {
    return dep.instanceId === test.instanceId;
};
const isUpdate = (dep) => (test) => {
    return dep.instanceId === test.instanceId && !refs.equal(dep.ref, test.ref);
};
const isConfigure = (dep) => (test) => {
    return dep.instanceId === test.instanceId && refs.equal(dep.ref, test.ref);
};
