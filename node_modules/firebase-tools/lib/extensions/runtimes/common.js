"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.extractExtensionsFromBuilds = exports.extractAllDynamicExtensions = void 0;
const projectConfig_1 = require("../../functions/projectConfig");
const prepare_1 = require("../../deploy/functions/prepare");
const functionsConfig_1 = require("../../functionsConfig");
const functionsDeployHelper_1 = require("../../deploy/functions/functionsDeployHelper");
const logger_1 = require("../../logger");
const savedLoggerSilent = logger_1.logger.silent;
function silenceLogging() {
    logger_1.logger.silent = true;
}
function resumeLogging() {
    logger_1.logger.silent = savedLoggerSilent;
}
async function extractAllDynamicExtensions(options) {
    const firebaseConfig = await (0, functionsConfig_1.getFirebaseConfig)(options);
    const runtimeConfig = { firebase: firebaseConfig };
    const functionsConfig = (0, projectConfig_1.normalizeAndValidate)(options.config.src.functions);
    let functionsBuilds = {};
    const codebases = (0, functionsDeployHelper_1.targetCodebases)(functionsConfig);
    silenceLogging();
    for (const codebase of codebases) {
        try {
            const filters = [{ codebase: `${codebase}` }];
            const builds = await (0, prepare_1.loadCodebases)(functionsConfig, options, firebaseConfig, runtimeConfig, filters);
            functionsBuilds = Object.assign(Object.assign({}, functionsBuilds), builds);
        }
        catch (err) {
        }
    }
    resumeLogging();
    return extractExtensionsFromBuilds(functionsBuilds);
}
exports.extractAllDynamicExtensions = extractAllDynamicExtensions;
function extractExtensionsFromBuilds(builds, filters) {
    const extRecords = {};
    for (const [codebase, build] of Object.entries(builds)) {
        if (build.extensions) {
            for (const [id, ext] of Object.entries(build.extensions)) {
                if (extensionMatchesAnyFilter(codebase, id, filters)) {
                    extRecords[id] = ext;
                }
            }
        }
    }
    return extRecords;
}
exports.extractExtensionsFromBuilds = extractExtensionsFromBuilds;
function extensionMatchesAnyFilter(codebase, extensionId, filters) {
    if (!filters) {
        return true;
    }
    return filters.some((f) => extensionMatchesFilter(codebase, extensionId, f));
}
function extensionMatchesFilter(codebase, extensionId, filter) {
    if (codebase && filter.codebase) {
        if (codebase !== filter.codebase) {
            return false;
        }
    }
    if (!filter.idChunks) {
        return true;
    }
    const idChunks = extensionId.split("-");
    if (idChunks.length < filter.idChunks.length) {
        return false;
    }
    for (let i = 0; i < filter.idChunks.length; i++) {
        if (idChunks[i] !== filter.idChunks[i]) {
            return false;
        }
    }
    return true;
}
